package main

import (
	"fmt"
	"github.com/tealeg/xlsx"
	"gopkg.in/ini.v1"
	"log"
	"os"
	"strconv"
	"strings"
)

var (
	indent = 0
)

type XLSXSheetInfo struct {
	SheetName string
	Table     [][]string
}

func NewXLSXSheetInfo(sheetName string) *XLSXSheetInfo {
	return &XLSXSheetInfo{
		SheetName: sheetName,
	}
}

type XLSXInfo struct {
	XLSXName string
	Sheets   []*XLSXSheetInfo
}

func NewXLSXInfo(XLSXName string) *XLSXInfo {
	return &XLSXInfo{XLSXName: XLSXName}
}

func ReadOneXLSX(dir string, excelFileName string) *XLSXInfo {
	retInfo := NewXLSXInfo(excelFileName)
	//fmt.Println("ReadOneXLSX dir:", dir, " excelFileName:", excelFileName, " outPutDir:", outPutDir)
	fmt.Println("开始读取:", excelFileName)
	xlFile, err := xlsx.OpenFile(dir + excelFileName)
	if err != nil {
		fmt.Printf("open failed: %s\n", err)
		return nil
	}
	for _, sheet := range xlFile.Sheets {
		sheetInfo := NewXLSXSheetInfo(sheet.Name)
		//fmt.Printf("Sheet Name: %s\n", sheet.Name)
		for _, row := range sheet.Rows {
			var rowInfo []string
			for _, cell := range row.Cells {
				text := cell.String()
				rowInfo = append(rowInfo, text)
				//fmt.Printf("%s\t", text)
			}
			sheetInfo.Table = append(sheetInfo.Table, rowInfo)
			//fmt.Println()
		}
		retInfo.Sheets = append(retInfo.Sheets, sheetInfo)
		//fmt.Println()
	}

	return retInfo
}

func WriteLine(file *os.File, str string) {
	for i := 0; i < indent; i++ {
		file.WriteString("\t")
	}
	file.WriteString(str + "\n")
}

func WriteOneXLSX(dir string, outputFileName string, info *XLSXInfo) {
	fmt.Println("WriteOneXLSX dir:", dir, " outputFileName:", outputFileName)

	goFile := dir + outputFileName
	file, err := os.OpenFile(goFile, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, os.ModePerm)
	if err != nil {
		fmt.Println("os.OpenFile failed. err:", err, " goFile:", goFile)
		return
	}
	defer file.Close()

	rowIdx := 0
	bFirstLine := true
	maxLength := 0

	bFirstLine = true
	for _, sheetInfo := range info.Sheets {
		for _, rowInfo := range sheetInfo.Table {
			if bFirstLine {
				bFirstLine = false
				continue
			}
			if len(rowInfo) < 2 {
				fmt.Println("WARNING: row error. rowIdx:", rowIdx, " info:")
				for element := range rowInfo {
					fmt.Println("element:", element)
				}
				continue
			}
			if maxLength < len(rowInfo[0]) {
				maxLength = len(rowInfo[0])
			}
		}
		break
	}

	WriteLine(file, "// This file is generated by code generation tool. DO NOT EDIT IT !!! contact uniqs@163.com for detail.")

	WriteLine(file, "")
	WriteLine(file, "package main")
	WriteLine(file, "")
	WriteLine(file, "const (")
	indent++

	rowIdx = 0
	bFirstLine = true
	for _, sheetInfo := range info.Sheets {
		for _, rowInfo := range sheetInfo.Table {
			if bFirstLine {
				bFirstLine = false
				continue
			}
			enumWithSpace := rowInfo[0]
			for i := 0; i < maxLength-len(rowInfo[0]); i++ {
				enumWithSpace += " "
			}
			WriteLine(file, enumWithSpace+" = "+strconv.Itoa(rowIdx))
			rowIdx++
		}
		break
	}

	indent--
	WriteLine(file, ")")

	WriteLine(file, "")

	WriteLine(file, "var (")
	indent++
	WriteLine(file, "ErrorStringCN []string")
	indent--
	WriteLine(file, ")")
	WriteLine(file, "")
	WriteLine(file, "func init() {")
	indent++

	rowIdx = 0
	bFirstLine = true
	for _, sheetInfo := range info.Sheets {
		for _, rowInfo := range sheetInfo.Table {
			if bFirstLine {
				bFirstLine = false
				continue
			}
			WriteLine(file, "ErrorStringCN = append(ErrorStringCN, \""+rowInfo[1]+"\")")
			rowIdx++
		}
		break
	}

	indent--
	WriteLine(file, "}")
}

func main() {
	iniFileName := "uniqs.ini"
	cfg, err := ini.Load(iniFileName)
	if err != nil {
		log.Fatal("ini.Load failed iniFileName:", iniFileName)
	}
	xlsxDir := cfg.Section("ErrorCode").Key("xlsx_dir").String()
	if !strings.HasSuffix(xlsxDir, "\\") && !strings.HasSuffix(xlsxDir, "/") {
		xlsxDir += "/"
	}
	fmt.Println("xlsx_dir:", xlsxDir)
	outPutDir := cfg.Section("ErrorCode").Key("output_dir").String()
	if !strings.HasSuffix(outPutDir, "\\") && !strings.HasSuffix(outPutDir, "/") {
		outPutDir += "/"
	}
	fmt.Println("output_dir:", outPutDir)

	err = os.MkdirAll(outPutDir, os.ModePerm)
	if err != nil {
		log.Fatal("os.MkdirAll failed. err:", err)
	}

	XLSXInfo := ReadOneXLSX(xlsxDir, "ErrorCode.xlsx")
	if XLSXInfo != nil {
		WriteOneXLSX(outPutDir, "ErrorCode.go", XLSXInfo)
	} else {
		fmt.Println("maybe file not exits: ErrorCode.xlsx")
	}
}
